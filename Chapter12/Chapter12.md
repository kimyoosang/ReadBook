# chapter12. 상속 다루기

- 이번 장에서는 객체 지향 프로그래밍에서 가장 유명한 특성인 상속을 다룬다
- 다른 강력한 메서니즘처럼 이 역시 아주 유용한 동시에 오용하기 쉽다. 더욱이 상속은 발등에 불이 떻어져서야 비로소 잘못 사용했음을 알아차리는 경우가 많다

## **12.1 메서드 올리기**

### **배경**

- 중복 코드 제거는 중요하다. 무언가 중복되었다는 것은 한쪽의 변경이 다른 쪽에는 반영되지 않을 수 있다는 위험을 항상 수반한다. 그러느데 일반적으로는 중복을 찾기가 그리 쉽지 않다는게 문제다
- 메서드 올리기를 적용하기 가장 쉬운 상화은 메서드들의 본문 코드가 똑같을 때다. 리팩터링이 제대로 되었는지를 검증하려면 테스트가 여전히 잘 동작하는지 확인하면 되지만, 테스트를 얼마나 잘 만들었느냐에 크게 의존하는 방법이다
- 그래서 차이점을 찾는 방법이 효과가 좋다. 테스트에서 놓친 동작가지 알게 해주는 경우가 자주있기 때문이다
- 메서드 올리기 리팩터링을 적용하려면 선행 단계를 거쳐야 할 때가 많다. 예컨대 서로 다른 두 클래스의 두 메서드를 각각 매개변수화하면 궁극적으로 같은 메서드가 되기도 한다. 이런 경우에 가장 적은 단계를 거쳐 리팩터링하려면 각각의 함수를 매개변수화 한 다음 메서들 상속 계층의 위로 올리면 된다
- 반면, 메서드 올리기를 적용하기에 가장 이상하고 복잡한 상황은 해당 메서드의 본문에서 참조하는 필드들이 서브클래스에만 있는 경우다. 이런 경우라면 필드들 먼저 슈퍼클래스로 올린 후에 메서드를 올려야 한다
- 두 메서드의 전체 흐름은 비슷하지만 세부 내용이 다르다면 **템플릿 메서드 만들기**를 고려해보자

### **절차**

1. 똑같이 동작하는 메서드인지 면밀히 살펴본다
2. 메서드 안에서 호출하는 다른 메서드와 참조하는 필드들을 슈퍼클래스에서도 호출하고 참조할 수 있는지 확인한다
3. 메서드 시그니처가 다르다면 함수 선언 바꾸기로 슈퍼클래스에서 사용하고 싶은 형태로 통일한다
4. 슈퍼클래스에 새로운 메서드를 생성하고, 대상 메서드의 코드를 복사해넣는다
5. 정적 검사를 수행한다
6. 서브클래스 중 하나의 메서드를 제거한다
7. 테스트한다
8. 모든 서브클래스의 메서드가 없어질 때까지 다른 서브클래스의 메서드를 하나씩 제거한다

### **예시**

- [메서드 올리기](./Example/PullUpMethod.md)

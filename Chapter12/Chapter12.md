# chapter12. 상속 다루기

- 이번 장에서는 객체 지향 프로그래밍에서 가장 유명한 특성인 상속을 다룬다
- 다른 강력한 메서니즘처럼 이 역시 아주 유용한 동시에 오용하기 쉽다. 더욱이 상속은 발등에 불이 떻어져서야 비로소 잘못 사용했음을 알아차리는 경우가 많다

## **12.1 메서드 올리기**

### **배경**

- 중복 코드 제거는 중요하다. 무언가 중복되었다는 것은 한쪽의 변경이 다른 쪽에는 반영되지 않을 수 있다는 위험을 항상 수반한다. 그러느데 일반적으로는 중복을 찾기가 그리 쉽지 않다는게 문제다
- 메서드 올리기를 적용하기 가장 쉬운 상화은 메서드들의 본문 코드가 똑같을 때다. 리팩터링이 제대로 되었는지를 검증하려면 테스트가 여전히 잘 동작하는지 확인하면 되지만, 테스트를 얼마나 잘 만들었느냐에 크게 의존하는 방법이다
- 그래서 차이점을 찾는 방법이 효과가 좋다. 테스트에서 놓친 동작가지 알게 해주는 경우가 자주있기 때문이다
- 메서드 올리기 리팩터링을 적용하려면 선행 단계를 거쳐야 할 때가 많다. 예컨대 서로 다른 두 클래스의 두 메서드를 각각 매개변수화하면 궁극적으로 같은 메서드가 되기도 한다. 이런 경우에 가장 적은 단계를 거쳐 리팩터링하려면 각각의 함수를 매개변수화 한 다음 메서들 상속 계층의 위로 올리면 된다
- 반면, 메서드 올리기를 적용하기에 가장 이상하고 복잡한 상황은 해당 메서드의 본문에서 참조하는 필드들이 서브클래스에만 있는 경우다. 이런 경우라면 필드들 먼저 슈퍼클래스로 올린 후에 메서드를 올려야 한다
- 두 메서드의 전체 흐름은 비슷하지만 세부 내용이 다르다면 **템플릿 메서드 만들기**를 고려해보자

### **절차**

1. 똑같이 동작하는 메서드인지 면밀히 살펴본다
2. 메서드 안에서 호출하는 다른 메서드와 참조하는 필드들을 슈퍼클래스에서도 호출하고 참조할 수 있는지 확인한다
3. 메서드 시그니처가 다르다면 함수 선언 바꾸기로 슈퍼클래스에서 사용하고 싶은 형태로 통일한다
4. 슈퍼클래스에 새로운 메서드를 생성하고, 대상 메서드의 코드를 복사해넣는다
5. 정적 검사를 수행한다
6. 서브클래스 중 하나의 메서드를 제거한다
7. 테스트한다
8. 모든 서브클래스의 메서드가 없어질 때까지 다른 서브클래스의 메서드를 하나씩 제거한다

### **예시**

- [메서드 올리기](./Example/PullUpMethod.md)

## 12.2 필드 올리기\*\*

### **배경**

- 서브클래스들이 독립적으로 개발되었거나 뒤늦게 하나의 계층구조로 리팩터링된 경우라면 일부 기능이 중복되어 있을 때가 왕왕있다. 특히 필드가 중복되기 쉽다. 이런 필드들은 이름이 비슷한게 보통이지만, 항상 그런것은 아니다. 그래서 어떤 일이 벌어지는지를 알아내려면 필드들이 어떻게 이용되는지 분석해봐야 한다
- 분석 결과 필드들이 비슷한 방식으로 쓰인다고 판단되면 슈퍼클래스로 끌어올린다
- 이렇게 하면 두 가지 중복을 줄일 수 있다
  1. 데이터 중복 선언을 없앨 수 있다
  2. 해당 필드를 사용하는 동작을 서브클래스에서 슈퍼클래스로 옮길 수 있다
- 동적 언저 중에는 필드를 클래스 정의에 포함시키지 않는 경우가 ㅁ낳다. 그 대신 필드에 가장 처음 값이 대입될 때 등장한다. 이런 경우라면 필드를 올리기 전에 반드시 생성자 본문부터 올려야한다

### **절차**

1. 후보 필드들을 사용하는 곳 모두가 그 필드들을 똑같은 방식으로 사용하는지 면밀히 살핀다
2. 필드들의 이름이 각기 다르다면 똑같은 이름으로 바꾼다(필드 이름 바꾸기)
3. 슈퍼클래스에 새로운 필드를 생성한다
4. 서브클래스의 필드들을 제거한다
5. 테스트한다

## **12.3 생성자 본문 올리기**

### **배경**

- 서브클래스들에서 기능이 같은 메서드들을 발견하면 함수 추출하기와 메서드 올리기를 차례로 적용하여 말끔히 슈퍼클래스로 옮기곤 한다
- 그런데 그 메서드가 생성자라면 스텝이 꼬인다. 생성자는 할 수 있는 일과 호출 순서에 제약이 있기 때문에 조금 다른 식으로 접근해야 한다

### **절차**

1. 슈퍼클래스에 생성자가 없다면 하나 정의한다. 서브클래스의 생성자들에서 이 생성자가 호출되는지 확인한다
2. 문장 슬라이드하기로 공통 문장 모두를 super() 호출 직후로 옮긴다
3. 공통 코드를 슈퍼클래스에 추가하고 서브클래스들에서는 제거한다. 생성자 매개변수 중 공통 코드에서 참조하는 값들을 모두 super()로 건넨다
4. 테스트한다
5. 생성자 시작 부분으로 옮길 수 없는 공통 코드에는 함수 추출하기와 메서드 올리기를 차례로 적용한다

### **예시**

- [생성자 본문 올리기](./Example/PullUpConstructorBody.md)

## **12.4 메서드 내리기**

### **배경**

- 특정 서브클래스 하나(혹은 소수)와만 관련된 메서드는 슈퍼클래스에서 제거하고 해당 서브 클래스(들)에 추가하는 편이 깔끔하다
- 다만, 이 리팩터링은 해당 기능을 제공하는 서브클래스가 정확히 무엇인지를 호출자가 알고 있을 때만 적용할 수 있다. 그렇지 못한 상황이라면 서브클래스에 따라 다르게 동작하는 슈퍼클래스의 기만적인 조건부 로직을 다형성으로 바꿔야 한다

### **절차**

1. 대상 메서드를 모든 서브클래스에 복사한다
2. 슈퍼클래스에서 그 메서드를 제거한다
3. 테스트한다
4. 이 메서드를 사용하지 않는 모든 서브클래스에서 제서한다
5. 테스트한다

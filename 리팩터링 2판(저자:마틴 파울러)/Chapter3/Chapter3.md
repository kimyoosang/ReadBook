# Chapter3. 코드에서 나는 악취

# <U>3.1 기이한 이름</U>

- 코드는 단순하고 명료하게 작성해야 하다. 코드를 명료하게 표현하는 데 가장 중요한 요소 하나는 바로 '이름'이다
- 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어덯게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 ㅏㅎㄴ다
- 이름만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다
- 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다

# <U>3.2 중복 코드</U>

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다
- 코드가 비슷하긴 한데 완전히 똑같지는 않다면, 먼저 문장 슬라이스하기로 비슷한 부분을 한곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 본다
- 같은 부모로부터 파생된 서브클래스들에 코드가 중복되어있다면, 각자 따로 호출되지 않도록 메서드 올리기를 적용해 부모로 옮긴다

# <U>3.3 긴 함수</U>

- 함수가 길수록 이해하기 어렵다. 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다
- 주석을 달아야 할 만한 부분을 무조건 함수로 만든다
- 함수를 짧게 만드는 작업의 99%는 함수 추출하기가 차지한다
- 추출할 코드 덩어리는 주석을 참고하면 쉽게 찾을 수 있는데, 주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려있는 경우가 많다
- 주석이 설명하는 코드를 빼내고, 함수 이름은 주석 내용을 토대로 짓는다
- 조건문이나 반복문도 추출 대상의 실마리를 제공한다

# <U>3.4 긴 매개변수 목록</U>

- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다
- 클래스는 매개변수 목록을 줄이는 데 효과적인 수단이다. 특히 여러개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 유용하다

# <U>3.5 전역 데이터</U>

- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는게 문제다
- 버그는 끊임없이 발생하는데 그 원인이 되는 코드를 찾아내기 어려운 경우가 있는데 전역 데이터가 이 예시다
- 이를 방지하기 위해서는 변수 캡슐화하기가 효과적이며 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다
- 전역 데이터가 아주 조금만 있더라도 캡슐화 하는 것이 좋다

# <U>3.6 가변 데이터</U>

- 가변 데이터를 변경하는 상황에서 코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하지 못한 채 수정해버리면 프로그램이 오작동하게된다
- 변수 캡슐화하기를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있게 한다
- 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 변수 쪼개기를 이용하여 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일응킬 여지를 없앤다
- 그러기 위해 문장 슬라이스하기와 함수 추출하기를 이용해서 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리한다
- 여러함수를 클래스로 묶기나 여러 함수를 변환 함수로 묶기를 이용해서 변수를 갱신하는 코드들의 유효범위를 제한한다

# <U>3.7 뒤엉킨 변경</U>

- 뒤엉킨 변경은 '단일 책임 원칙'이 제대로 지켜지지 않을때 나타난다. 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러가지 방식으로 변경되는 일이 많을때 발생한다
- 서로 다른 맥락에서 이뤄지므로 독립된 모듈로 분리해야 프로그래밍이 편하다

# <U>3.8 산탄총 수술</U>

- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 발생한다
- 함께 변경되는 대상들을 함수 옮기기와 필드 옮기기로 모두 한 모듈에 묶어두면 좋다
- 비슷한 데이터를 다루는 함수가 많다면 여러 함수를 클래스로 묶기를 적용한다
- 데이터 구조를 변환하거나 보강 하는 함수들에는 여러 함수를 변환 함수로 묶기를 적용한다
- 어설프게 분리된 로직을 함수 인라인하기나 클래스 인라인하기 같은 인라인 리팩터링으로 하나로 합치는 것도 산탄총 수술에 대처하는 좋은 방법이다
- 메서드나 클래스가 비대해지지만, 나중에 추출하기 리팩터링으로 더 좋은 형태로 분리할 수도 있다

# <U>3.9기능 편애</U>

- 프로그램을 모듈화할 떄는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는데 주력한다
- 기능 편애는 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 나타난다
- 기능 편애를 해결하는 방법은 함수가 자주 참조하는 데이터 근처로 함수를 옮긴다
- 함수의 일부에서만 기능 편애가 일어날 때는 그 부분만 독립 함수로 뺀 다음 다른 모듈로 옮긴다
- 어디로 옮길지 명확하게 들어나지 않을 때는 가장 많은 데이터를 포함한 모듈로 옮기거나, 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮기면 더 쉽게 해결되는 경우가 많다
- 데이터와 이를 활용하는 동작은 함께 변경되는 경우가 아니라면 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮긴다

# <U>3.10 데이터 뭉치</U>

- 데이터 항목 서너 개가 여러 곳에서 항상 함께 뭉쳐다니는 모습을 볼 수 있는데, 데이터 뭉치인지 판변하려면 값 하나를 삭제했을 때 나머지 데이터만으로는 의미가 없다면 객체로 만드는 것이 좋은 데이터 뭉치인것을 알 수 있다
- 먼저 필드 평태의 데이터 뭉치를 찾아서 클래스 추출하기로 하나의 객체로 묶는다
- 다음 메서드 시그니처에 있는 데이터 뭉치의 매개변수 수를 줄인다

# <U>3.11 기본형 집착</U>

- 문제에 딱 맞는 기초 타입(화폐,좌표,구간 등)을 직접 정의하기 꺼려하는 경우가 많다. 예를 들어서 전화번호를 단순히 문자 집합으로만 표현하는 경우인데 최소한 사용자에게 보여줄 때는 일관된 형식으로 출력해주는 기능이라도 갖춰야 한다
- 자료형들에 기본형을 객체로 바꾸기를 적용한다
- 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면 타입 코드를 서브클래스로 바꾸기와 조건부 로직을 다형성으로 바꾸기를 차례로 적용한다

# <U>3.12 반복되는 switch문</U>

- 똑같은 조건부 로직(switch/case문이나 길게 나열된 if/else)이 여러 곳에서 반복해 등장하는 코드에 집중한다
- 중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해햐 하기 때문이다
- 이런 부분들은 조건부 로직을 다형성으로 바꾸기를 이용해 없애준다

# <U>3.13 반복문</U>

- 최근에는 일급함수를 지원하는 언어가 많아졌기 때문에 반복문을 파이프라인으로 바꾸기를 적용해서 시대에 걸맞지 않은 반복문을 제거할 수 있게 됐다
- 필터나 맵같은 파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다

# <U>3.14 성의 없는 요소</U>

- 코드의 구조를 잡을 때 프로그램 요소(함수,클래스,인터페이스 등)를 이용하는 경우가 많은데 그 구조가 필요 없을 때도 있다
- 함수 인라인하기나 클래스 인라인하기로 처리한다
- 상속을 사용했다면 계층 합치기를 적용한다

# <U>3.15 추측성 일반화</U>

- '나중에 필요할 거야'라는 생각으로 당장은 필요없는 모든 종류의 후킹포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다. 그 결과는 이해하거나 관리하기 어려워진 코드다.
- 추측성 일반화는 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 볼 수 있다
- 하는 일이 거의 없는 추상 클래스는 계층 합치기로 제거한다
- 쓸데없이 위임하는 코드는 함수 인라인하기나 클래스 인라인하기로 삭제한다
- 본문에서 사용되지 않는 매개변수는 함수 선언 바꾸기로 없앤다

# <U>3.16 임시 필드</U>

- 특정 상황에서만 값이 설정되는 필드를 가진 클래스가 있는데 객체를 가져올 때는 당연히 모든 필드가 패워져 있으리라 기대하는것이 보통이기 때문에 임시 필드를 갖도록 작성하면 코드를 이해하기 어렵다
- 먼저 클래스 추출하기로 제 살곳을 찾아준다
- 그런 다음 함수 옮기기로 임시 필드들과 관련된 코드를 모조리 새 클래스에 몰아넣는다
- 또 임시 필드들이 유효한지를 확인한 후 동작하는 조건부 로직이 있다면, 특이 케이스 추가하기로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거한다

# <U>3.17 메시지 체인</U>

- 메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다
- 예를 들어 getSomething()같은 게터가 꼬리에 꼬리를 물고 이어지거나 임시 변수들이 줄줄이 나열되는 코드가 있을 때 이는 클라이언트가 객체 네비게이션 구조에 종속됐음을 의미한다. 그래서 네비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다
- 최종 결과 객체가 어떻게 쓰이는지 함수 추출하기와 함수 옮기기로 체인을 숨길 수 있는지 살펴보고 위임 숨기기로 해결한다

# <U>3.18 중개자</U>

-

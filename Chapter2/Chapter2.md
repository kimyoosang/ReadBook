# Chapter2. 리팩터링 원칙

## <U>2.1 리팩터링 정의</U>

- 리팩터링[명사]: 소프트웨어의 겉보기 동작은 그대로 유지한 채,코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 방법
- 리팩터링[동사]: 소프트웨어의 겉보기 동작은 그대로 유지한채, 여러가지 리팩터링 기업을 적용해서 소프트웨어를 재구성하다

  - 지금껏 수많은 사람이 코드를 정리하는 작업을 모조리 '리팩터링'이라고 표현하고 있는데, 앞에서 제시한 정의를 따르면 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다
  - 한번에 나눌 수 있는 작업을 수많은 단계로 잘게 나눠서 작업하면 리팩터링 하는것이 비효율적이라고 생각하기 쉽다. 그러나 단계들이 체계적으로 구성되어있기 때문에 디버깅하는 시간을 줄여줘서 오히려 작업이 더 빨라진다
  - 리패터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다
  - 리팩터링 전과 후의 코드가 똑같이 작동해야한다. 심지어 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아있어야 한다

## <U>2.2 두 개의 모자</U>

- **소프트웨어를 개발할 때 목적이 '기능 추가'냐, 아니면 '리팩터링'이냐를 명확히 구분해 작업한다**
  - 기능을 추가할 때는 기존 코드는 절대 건드릴지 않고 새 기능을 추가하기만 한다
  - 리팩터링할 때는 기능추가는 절대 하지 않기로 다짐한 뒤 오롤지 코드 재구성에만 전념한다

## <U>2.3 리팩터링하는 이유</U>

- **리팩터링하면 소프트웨어 설계가 좋아진다**

  - 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다
  - 코드만으로 설계르 파악하기 어려워질수록 설계를 유지하기 어려워지고, 설계가 부패되는 속도는 더욱 빨라진다
  - 중복 코드 제거는 설계 개선 작업의 중요한 축을 차지한다
  - 코드가 길수록 실수 없이 수정하기 어려워진다. 이해해야 할 코드량도 늘어난다
  - 중복코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있다
  - <U>규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다</U>

- **리팩터링하면 소프트웨어를 이해하기 쉬워진다**

  - 다른 프로그래머가 내 코드를 제대로 이해했다면 한 시간에 끝낼 수정을 일주일이나 걸린다면 문제가 된다. 그리고 때때로 이 프로그래머는 나 자신이 되는 순간이 많다
  - 프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드르 다룰 개발자를 배려하지 못한다
  - <U>리팩터링은 코드가 더 잘 읽히게 도와주고 코드의 목적이 잘 드러나게, 다시 말해 내 의도르 더 명확하게 전다하도록 개선할 수 있다</U>

- **리팩터링하면 버그를 쉽게 찾을 수 있다**

  - 리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다
  - 리팩터링은 코드의 구조를 명확하게 다듬어주고 견고한 코드 작성하는데 무척 효과적이다

- **리팩터링하면 프로그래밍 속도르 높일 수 있다**
  - 한 시스템을 왜 개바하게되면 코드베이스에 패치에 패치가 더해져서 나중에는 프로그램의 동작을 이해하기도 힘들고 버그파악,새로운 기능추가가 어려워 진다
  - 초기 개발속도는 빠르나 장기적으로 봤을 때 개발속도가 느리다
  - 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다
  - <U>설계 지구력 가설: 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다</U>

## <U>2.4 언제 리팩터링해야 할까?</U>

- **3의 법칙**

1. 처음에는 그냥 한다
2. 비슷한 일을 두 번째로 하게되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다

- **준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**

  - <U>리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다</U>
  - 이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다
  - 기능을 추가할 때 복제하는 경우가 많은데 만약 원복 코드에 버그가 있다면 나중에 복제한 코드들을 전부 수정해야한다
  - 리팩터링으로 상황을 개선해놓으면 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에, 같은 곳에서 다른 버그가 발생활 가능성을 줄일 수도 있다<br></br>

- **이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**

  - 코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다
  - 리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다
  - 내가 이해한 것을 코드에 반영해두면 더 오래 보존할 수 있을 뿐만 아니라 동료들도 알 수 있다
  - 코드가 깔끔하게 정리되면 전에는 보이지 않던 설계가 눈에 들어오는데, 이 모든 변경을 머릿속으로 시뮬레이션해볼 만큼 머리가 좋지 않다면 코드를 정리하여 영원히 보지 못하고 지나쳤을지 모를것들을 볼 수 있다
  - <U>코드를 분석할 때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다</U><br></br>

- **쓰레기 줍기 리팩터링**

  - 코드를 파악하던 중 리팩터링해야할 코드가 보이는데 원래 하려던 작업과 관련없는 일에 너무 많은 시간을 빼앗기기 싫을것이다
  - <U>간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모를 남긴다. 이것이 리팩터링의 변형인 쓰레기 줍기 리펙터링이다</U>
  - 코드를 훑어볼 때마다 조금씩 개선하다 보면 결국 문제가 해결된다<br></br>

- **계획된 리팩터링과 수시로 하는 리팩터링**

  - 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다. 리팩터링 시간을 일정에 따로 잡아두지 않고, 대부분의 리팩터링을 다른 일을 하는 중에 처리한다
  - 계획된 리팩터링이 무조건 나쁜것은 아니다. 그동안 리팩터링에 소홀했다면, 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있다
  - 어떤 리팩터링은 팀원 여럿이 달려들어야 할 정도인것이 있는데, 이런 이유로 계획된 리팩터링을 하는 것은 최소한으로 줄여야 한다. 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다<br></br>

- **오래 걸리는 리팩터링**

  - 팀 전체가 리팩터링에 매달리기 보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해 나가는 편이 효과적일 때가 많다
  - 누구든지 리팩터링해야할 코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 식이다
  - 리팩터링이 코드를 깨트리지 않는다는 장점을 활용하여 예컨데 라이브러리를 교체할 때는 기존 것과 새 것 모두를 포용하는 추상 인터페이스부터 마련한다<br></br>

- **코드 리뷰에 리팩터링 활용하기**

  - 리팩터링은 다른 이의 코드를 리뷰하는데 도움이 된다
  - 새로운 아이디어가 떠오르면 리펙터링하여 쉽게 구현해넣을 수 있는지부터 보게되고 쉽다면 실제로 리팩터링한다
  - 리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움이 된다
  - 코드 리뷰에 리팩터링을 접목하는 구체적인 방법중 가장 좋은 방법은 작성자와 나란히 앉아서 리팩터링하는 것이다. 이렇게 하면 자연스럽게 페어프로그래밍이 된다<br></br>

- **관리자에게는 뭐라고 말해야 할까?**

  - 관리자가 기술에 정통하고 설계 지구력 가설도 잘 이해하고 있다면 리팩터링의 필요성을 쉽게 설득할 수 있다
  - 기술을 모르는 상당수의 관리자와 고객은 코드베이스의 건강 상태가 생산성에 미치는 영향을 모른다
  - <U>프로 개발자의 역할은 효과적인 소프트웨어를 최대한 빨리 만드는 것이다. 그리고 가장 빠른 방법은 리팩터링이다</U><br></br>

- **리팩터링하지 말아야 할 때**
  - 외부 API 다루듯 호출해서 쓰는 코드거나 처음부터 새로 작성하는게 쉬울때도 리팩터링하지 않는다
  - 그러나 리팩터링을 할지 안할지 결정하려면 뛰어난 판단력과 경험이 필요하기 때문에 이 판단에 대해서는 한 마디 조언으로 표현하기 힘들다

## <U>2.5. 리팩터링 시 고려할 문제</U>

- **새 기능 개발 속도 저하**
  - 내가 직접 건드릴 일이 거의 없거나, 불편한 정도가 그리 심하지 않다고 판단되면 리팩터링하지 않는편
  - 그러나 리팩터링 할지 말지를 판단하는 능력은 수년에 걸친 경험을 통해 서서히 형성된다. 리더는 리팩터링 경험이 부족한 이들이 이런 능력을 빠르게 갖추도록 개발 과정에서 많이 이끌어줘야 한다
  - <U>리팩터링하도록 이끄는 동력은 경제적인 효과에 있다. 리팩터링은 '클린코드'처럼 코드를 이쁘게 짜려는 것이 아니라 개발 기간을 단축하고자 하는 오로지 경제적인 이유로 하는 것이다</U><br></br>
- **코드 소유권**

  - 코드 소유권이 나위어 있으면 리팩터링에 방해가 된다. 복잡해지긴 하지만 그렇다고 리팩터링을 할 수 없는건 아니다
  - 코드의 소유권을 팀에 두는것이 좋다. 그래서 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 한다
  - 어떤 팀은 다른 팀 사람이 자기 팀 코드의 브랜치를 따서 수정하고 커밋을 요청하는, 흡사 오픈소스 개발 모델을 권장하기도 하는데 이렇게 하면 함수의 클라이언트도 바꿀 수 있다. 이 방식은 코드 소유권을 엄격히 제한하는 방식과 완전히 풀어서 변경을 통제하기 어려운 방식을 절충한 것으로, 대규모 시스템 개발 시 잘 어올린다<br></br>

- **브랜치**

  - 흔히 볼 수 있는 팀 단위 작업방식은 코드베이스의 브랜치를 팀원이 하나씩 맡아서 작업하다가, 결과물이 어느 정도 쌓이면 마스터 브랜치에 통합하는 것이다
  - 이런 기능 브랜치 방식에는 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기 어렵다는 단점이 있다
  - 4주가 작업한 브랜치들을 통합하는 노력은 2주간 작업한 브랜치들을 통합할 때보다 두 배 이상 든다. 그러므로 기능별 브랜치의 통합 주기를 최대한 짧게 유지하는 것을 선호한다. 이 방식을 지속적 통합(CI)라고 한다
  - CI는 머지의 복잡도를 줄이기도 하지만 리팩터링과 궁합이 좋다. CI를 완벽히 적용하지 못하더라도 통합 주기만큼은 최대한 짧게 잡아야 한다<br></br>

- **테스팅**

  - 리팩터링 하기 위해서는 자가 테스트코드를 마련해야 한다
  - 자가 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다
  - 이때 핵심은 테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있다는 데 있다
  - 또한 리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불안감을 해소할 수 있다<br></br>

- **레거시 코드**

  - 레거시 시스템을 파악할 때 리팩터링이 굉장히 도움된다. 그러나 대규코 레거시 시스템을 테스트 코드 없이 명료하기 리팩터링을 하기는 어려운데, 이 문제의 정답은 당연히 테스트 보강이다
  - 그러나 쉽게 해결할 방법은 없다. 그라나 프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트하는 것이 방법이 될 수 있는데 이러한 틈새를 만들 때 리팩터링이 활용된다
  - 레거시 코드를 한번에 리팩터링하는것도 어렵기 때문에 서로 관련된 부분끼리 나눠서 하나씩 공력하고 코드의 한 부분을 훑고 넘어갈 때마다 조금이라도 개선하려고 노력한다<br></br>

- **데이터베이스**
  - 데이터베이스 리팩터링은 프라모드 사달게가 개발한 '진화형 데이터베이스 설계'와 '데이터베이스 리팩터링'을 활용하면 좋은데 이 기업도 다른 리팩터링과 마찬가지로 핵심은 전체 변경과정을 작고 독립된단계들로 쪼개는 것이다
  - 데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다

## <U>2.6 리팩터링, 아키텍처, 애그니(YAGNI)</U>

- 리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해준다는 데 있다
- 코딩 전에 아키텍처를 확정지으려 할 때의 대표적인 문제는 막상 소프트웨어를 사용해봐야 원하는 부분을 알게된다는 것이다
- 한 가지 방법은 유연성 메커니즘인데 이는 예상 시나리오에 대응하기 위한 매개변수들을 추가하는 것이다. 그러나 유연성 메커니즘이 오히려 변화에 대응하는 능력을 떨어뜨릴 때가 대부분이다
- 리팩터링을 활용하면 추측하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다
- 이런 식으로 설계하는 방식을 '간결한 설계', '점진적 설계', 'YAGNI(애그니)'라고 부른다. 그러나 이것이 아키텍처를 전혀 고려하지 말라는 뜻은 아니다. 리팩터링으로는 변경하기 어려워서 미리 생각해두면 시간이 절약되는 경우도 얼마든지 있다

## 2.7 <U>리팩터링과 소프트웨어 개발 프로세스</U>

- 익트스림 프로그래밍(XP)의 특징은 지속적 통합, 자가 테스트 코드, 리팩터링 등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스라는 점이다
- 리팩터리으이 첫 번째 토대는 자가 테스트 코드이고 리팩터링을 하려면 각 팀원이 다른 사람의 작업을 방해하지 말아야 하는데 이것이 지속적 통합을 적극 권장하는 이유이다.
- 자가 테스트 코드, 지속적 통합, 리팩터링이라는 세기법은 서로 강력한 상승효과를 발위하며 제 가지 실천법을 잘 조화시키면 요구사항 변화에 재빠르게 대응하고 안정적인 선순환 구조를 코드베이스에 심을 수 있다

## <U>2.8 리팩터링과 성능</U>

- 리팩터링 하면 소프트웨어가 느려질 수도 있는건 사실이다. 하지만 그와 동시에 성능을 튜닝하기 더 쉬워진다
- 빠른 소프트웨어를 작성하는 방법은 여러가지가 있지만 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경쓰지 않고 코드를 다루기 쉽게 만든데 집중하는 방법이 있다.
- 그러다 성능 최적화 단계가 되면 먼저 프로파일러로 프로그램을 분석하여 시간을 잡아먹는 지점을 알아낸뒤 성능에 큰 영향을 주는 작은 부분을 찾아 개선한다
- 이렇게 하면 성능에 큰 영향을 주는 부분만 집중해서 최적화하기 때문에 적은 노력으로 훨씬 큰 효과를 볼 수 있다
- 그리고 나서 각 단계마다 컴파일과 테스트를 거치고 프로파일러는 다시 실행하면서 성능이 개선되지 않았다면 수정내용을 되돌리고 다시 최적화 대상을 찾아서 제거한다
- 단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수도 있지만 최적화 단계에서 코드를 튜닝하기 훨씬 쉬어지기 때문에 결국 더 빠른 소프트웨어를 얻게된다

## <U>2.9 리팩터링의 유래</U>

- '리팩터링'이란 용어의 정확한 유래는 찾을수 없다
- 리팩터링의 중요함을 깨달은 선구자들은 스몰토크를 활용해 개발해왔고 스몰토크는 컴파일-링크-실행 주기가 상당히 짧아서 마지막으로 컴파일한 시점을 안다면 수정 작업을 빠르게 진행할 수 있었다
- 리팩터링이란 개념이 스몰토크 개발 문화에 중요한 요소로 자리잡고 빌 옵다이크라는 사람은 리팩터링의 잠재 가치를 간파하고 스몰토크를 넘어 다른 언어들에게도 적용했는데 이를 이용하여 존 브랜트와 돈 로버츠는 최초의 리팩터링 도구인 '리팩터링 브라우저'를 개발했다
- 앞에서 언급한 리팩터링 전문가 중에서 그런 책을 쓰겠다는 사람이 없었기 때문에 마틴 파울러는 이 책을 집필했고 리팩터링이란 말이 주류 개발 기법으로 자리잡게 되었다

## <U>2.10 리팩터링 자동화</U>

- 리팩터링을 자동화하는 가장 어설픈 방법은 '찾아 바꾸기'와 같은 소스 코드의 텍스트를 직접 조작하는 것이다. 이는 헛점이 많이 때문에 신뢰하기 힘들다
- 자동 리팩터링을 제대로 구현하려면 구문 트리를 조작하는 방식이 코드의 원래 의미를 보전하는데 훨씬 유리하기 때문에 구문 트리로 해석해서 다뤄야 한다. 그래서 뛰어난 IDE가 자동 리팩터링도 더 풍부하게 제공하는 경우가 많다
- 정적 타입 언어라면 훨씬 안전하게 구현할 수 있는 리팩터링 수가 늘어난다. 예를 들어서 두 개의 클래스의 같은 이름의 함수가 있다고 가정했을 때, 함수 이름을 바꾸고 싶으면 어디에 있는 함수를 바꾸는 건지 구분하기 힘들다. 그러나 자바같은 정적 코드라면 정접 타입 능력을 활용하여 메서드가 속한 클래스를 정확히 알아낼 수 있다
- IDE가 제공하는 리팩터링 기능이 강력하기 때문에 텍스트 에디터만 도집하기 말고 IDE를 사용하는것이 효율적이며, 재부분의 리팩터링이 믿을만 하더라도 중간에 꼬인 부분이 없는지 이따금 테스트로 확인한는 것이 바람직하다
